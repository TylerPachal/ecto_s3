defmodule MyXqlExamples do
  @moduledoc """
  The purpose of this files is just to collect all of the functionality of the
  MyXQL adapter, which we are using to model behaviour for EctoS3.

  EctoS3 will not be able to support all options/functions because S3 has
  limited functionality compared to a relational database.
  """
  use ExUnit.Case, async: false
  import S3Helpers
  alias EctoS3.Support.{SqlRepo, S3Repo}

  setup_all do
    {:ok, _pid} = S3Repo.start_link()
    {:ok, _pid} = SqlRepo.start_link()
    :ok
  end

  setup do
    # Clean S3 buckets between tests
    reset_buckets()

    # Clean database between tests
    Ecto.Adapters.SQL.query!(SqlRepo, "DROP TABLE IF EXISTS people")
    Ecto.Adapters.SQL.query!(SqlRepo, "CREATE TABLE people (id binary(16) primary key, name VARCHAR(100), age integer)")

    :ok
  end

  defmodule Person do
    use Ecto.Schema
    @primary_key {:id, :binary_id, autogenerate: true}
    schema "people" do
      field :name, :string
      field :age, :integer
    end
  end

  # https://hexdocs.pm/ecto/Ecto.Repo.html#c:insert/2-options
  describe "insert/2" do
    test ":returning - true" do
      options = [returning: true]
      struct = %Person{name: "tyler", age: 100}

      assert_raise(
        ArgumentError,
        "MySQL does not support :read_after_writes in schemas for non-primary keys. The following fields in MyXqlExamples.Person are tagged as such: [:age, :name, :id]",
        fn ->
          SqlRepo.insert(struct, options)
        end
      )

      assert_raise(
        ArgumentError,
        "S3 does not support :read_after_writes in schemas for non-autogenerated-primary keys.  The following fields in MyXqlExamples.Person are tagged as such: [:age, :name, :id]",
        fn ->
          S3Repo.insert(struct, options)
        end
      )
    end

    test ":returning - false" do
      options = [returning: false]
      struct = %Person{name: "tyler", age: 100}

      assert {:ok, %Person{id: id, name: "tyler", age: 100}} = SqlRepo.insert(struct, options)
      assert id != nil

      assert {:ok, %Person{id: id, name: "tyler", age: 100}} = S3Repo.insert(struct, options)
      assert id != nil
    end

    test ":returning - list of fields" do
      options = [returning: [:name]]
      struct = %Person{name: "tyler", age: 100}

      assert_raise(
        ArgumentError,
        "MySQL does not support :read_after_writes in schemas for non-primary keys. The following fields in MyXqlExamples.Person are tagged as such: [:name]",
        fn ->
          SqlRepo.insert(struct, options)
        end
      )

      # TODO: Currently it looks like we return the whole thing whenever the
      # :returning option is set to anything but `true`.  Can we make our
      # adapter respect the list?
    end

    test ":prefix" do
      # Inentionally not making this the same as the MyXQL version - using a :path_prefix instead
      # for similar but differing behavior.
    end
  end

  describe "delete/2" do
    test "delete using struct" do
      struct = %Person{name: "tyler", age: 100}
      assert {:ok, sql_struct} = SqlRepo.insert(struct)
      assert {:ok, s3_struct} = S3Repo.insert(struct)

      assert {:ok, %Person{}} = SqlRepo.delete(sql_struct)
      assert {:ok, %Person{}} = S3Repo.delete(s3_struct)
    end

    test "delete using changeset" do
      struct = %Person{name: "tyler", age: 100}
      assert {:ok, sql_struct} = SqlRepo.insert(struct)
      assert {:ok, s3_struct} = S3Repo.insert(struct)

      sql_changeset = Ecto.Changeset.change(sql_struct)
      s3_changeset = Ecto.Changeset.change(s3_struct)

      SqlRepo.delete(sql_changeset)
      S3Repo.delete(s3_changeset)
    end

    test "delete something which is not present" do
      struct = %Person{id: Ecto.UUID.generate()}
      assert_raise Ecto.StaleEntryError, fn ->
        SqlRepo.delete(struct)
      end

      # The S3 Delete operation is idempotent and never seems to fail (even if
      # there is nothing to delete).
      # assert_raise Ecto.StaleEntryError, fn -> S3Repo.delete(struct) end
    end

    test "delete something that has no primary key value" do
      struct = %Person{name: "tyler", age: 100}

      assert_raise Ecto.NoPrimaryKeyValueError, fn ->
        SqlRepo.delete(struct)
      end

      assert_raise Ecto.NoPrimaryKeyValueError, fn ->
        S3Repo.delete(struct)
      end
    end
  end
end
