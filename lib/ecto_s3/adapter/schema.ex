defmodule EctoS3.Adapter.Schema do

  @behaviour Ecto.Adapter.Schema

  @impl true
  def autogenerate(:id), do: :erlang.unique_integer()
  def autogenerate(:binary_id), do: Ecto.UUID.generate()

  @impl true
  def insert_all(_adapter_meta, _schema_meta, _header, _list, _on_conflict, _returning, _options) do
    raise "insert_all not supported"
  end

  @impl true
  def insert(adapter_meta, schema_meta, fields, _on_conflict, returning, options) do
    %{bucket: bucket, format: format} = adapter_meta
    %{source: source, prefix: _prefix, schema: schema_module} = schema_meta

    if Keyword.get(options, :returning) == true do
      raise ArgumentError, message: "S3 does not support :read_after_writes in schemas for non-autogenerated-primary keys.  The following fields in #{inspect(schema_module)} are tagged as such: #{inspect(returning)}"
    end

    key = key(schema_meta, fields)
    payload = payload(format, fields)
    headers = [content_type_header(format)]

    path = "/" <> Enum.join([source, key], "/") <> extension(format)

    ExAws.S3.put_object(bucket, path, payload)
    |> ExAws.request!(headers)

    {:ok, []}
  end

  @impl true
  def update(adapter_meta, schema_meta, _fields, _filters, _returning, _options) do
    %{repo: repo} = adapter_meta
    %{schema: schema} = schema_meta

    module = Module.split(repo) |> List.last()
    schema = Module.split(schema) |> List.last()

    raise """
      #{module}.update/2 is not supported.

      Since S3 only has basic write, read, and delete operations, there is no
      distinction between updating an existing file and writing a new file.
      Because of this the #{module}.update/2 function is not implemented and
      should be replaced by a combination of #{module}.get/2 and
      #{module}.insert/1:

        value = #{module}.get(#{schema}, id)
        updated_value = ...
        #{module}.insert(update_value)
      """
  end

  @impl true
  def delete(adapter_meta, schema_meta, filters, options) do
    {:ok, []}
  end

  defp key(schema_meta, fields) do
    keys = schema_meta.schema.__schema__(:primary_key)
    if keys == [] do
      raise Ecto.NoPrimaryKeyFieldError, schema: schema_meta.schema
    end

    # There may be more than one key if the schema is using a composite primary
    # key.  Concatenate them with dashes.
    Enum.map(keys, fn key ->
      case Keyword.fetch(fields, key) do
        {:ok, val} ->
          val
        :error ->
          raise Ecto.NoPrimaryKeyValueError, struct: schema_meta.schema.__struct__
      end
    end)
    |> Enum.join("-")
  end

  defp payload(:json, fields) do
    fields
    |> Map.new()
    |> Poison.encode!()
  end

  defp content_type_header(:json) do
    {:content_type, "application/json"}
  end

  defp extension(:json) do
    ".json"
  end
end
